/*
 * Copyright (c) 2009-2017 Valery Ushakov
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef _FORTH_H_
#define _FORTH_H_

#include <machine/asm.h>

/* Don't depend on whether <machine/asm.h> has these or doesn't */
#undef  __CONCAT
#define __CONCAT(x,y)   x ## y
#undef  __STRING
#define __STRING(x)     #x

#undef  ___CONCAT
#undef  ___STRING
#define ___STRING(x)    __STRING(x)
#define ___CONCAT(x,y)  __CONCAT(x,y)


/**
 *
 * Macros for manually defining the core Forth system.
 *
 */


#define NAMED_CELLS(n, label)	  \
	.p2align 2		; \
	.type	label, @object	; \
	.size	label, (n) * 4	; \
  label:			;

#define NAMED_CELL(label) \
  NAMED_CELLS(1, label)


#define DEFCODE_ASM(label)			  \
	/* Code Field */			  \
  NAMED_CELL(label)				; \
	.long	__CONCAT(label,_code)		; \
	/* Parameter Field */			  \
	.type	__CONCAT(label,_code),@function	; \
  __CONCAT(label,_code):

#define ASMEND(label) \
	.size	__CONCAT(label,_code), .-__CONCAT(label,_code)


#define DEFCODE_C(label)		  \
	/* Code Field */		  \
  NAMED_CELL(label)			; \
	.long	c_does			; \
	/* Parameter Field */	  	  \
  NAMED_CELL(__CONCAT(label,_fn))


#define DEFCODE_4TH(label)	  \
	/* Code Field */	  \
  NAMED_CELL(label)		; \
	.long	call_code	; \
	/* Parameter Field */	  \
  __CONCAT(label,_body):


#define DEFCODE_VAR(label)	  \
	/* Code Field */	  \
  NAMED_CELL(label)		; \
	.long	var_does	; \
	/* Parameter Field */	  \
  NAMED_CELL(__CONCAT(label,_var))


/* NB: Relies on the fact that transpiler's DOES> emits "_does" suffix */
#define DEFCODE_DOES(label, creator, n, suffix)	  \
	/* Code Field */			  \
  NAMED_CELL(label)				; \
	.long	__CONCAT(creator,_does)		; \
	/* Parameter Field */			  \
  NAMED_CELLS(n, __CONCAT(label,suffix))


#define DEFCODE_CONST(label)	DEFCODE_DOES(label, constant, 1, _const)
#define DEFCODE_2CONST(label)	DEFCODE_DOES(label, _2constant, 2, _2const)
#define DEFCODE_DEFER(label)	DEFCODE_DOES(label, defer, 1, _xt)


#define EXIT_4TH		  \
	.long	exit_4th


#define NFA_LABEL(label) __CONCAT(.L,label)

/*
 * Hand-compiled forth code uses IMMWORD() that passes IFLAG
 * explicitly.
 *
 * Transpiled forth code (where "immediate" only comes after the
 * definition) relies on assembler to supply the correct value to the
 * IMMEDIATE used below.
 *
 *     #undef  IMMEDIATE
 *     #define IMMEDIATE .Limm_word // absolute symbol for as(1) to resolve
 *     WORD("word", word) ...
 *     IMMEDIATE = IFLAG ! generated by "immediate", if present
 *     IMMEDIATE = 0     ! default, as(1) resolves to the first assignment
 */
#define NAME_FIELD(name, flags, label)    \
	.p2align 2, 0			; \
  NFA_LABEL(label):			  \
	.byte	IMMEDIATE | flags | (2f-1f)	; \
1:	.ascii	name			; \
2:	.p2align 2, 0

/*
 * Before the transpiler output supplies (re)definitions for
 * IMMEDIATE, provide a placeholder value.
 */
#define IMMEDIATE 0


#define DEFWORD(name, flags, defcode, label)	  \
  	NAME_FIELD(name, flags, label)		; \
	/* Link Field */			  \
  NAMED_CELL(__CONCAT(label,_lnk))		; \
	.long	.LASTNFA			; \
  .LASTNFA = NFA_LABEL(label)			; \
	defcode(label)

#define	IFLAG	0x80		/* immediate */
#define	SFLAG	0x40		/* smudge */

#define WORD(name, label)	DEFWORD(name,     0, DEFCODE_4TH,   label)
#define IMMWORD(name, label)	DEFWORD(name, IFLAG, DEFCODE_4TH,   label)
#define ASMWORD(name, label)	DEFWORD(name,     0, DEFCODE_ASM,   label)
#define CWORD(name, label)	DEFWORD(name,     0, DEFCODE_C,     label)
#define DEFER(name, label)	DEFWORD(name,     0, DEFCODE_DEFER, label)
#define CONSTANT(name, label)	DEFWORD(name,     0, DEFCODE_CONST, label)
#define VARIABLE(name, label)	DEFWORD(name,     0, DEFCODE_VAR,   label)

#define TWO_CONSTANT(name, label) DEFWORD(name, 0, DEFCODE_2CONST, label)

#define NONAME(label)				  \
	NAME_FIELD("", SFLAG, label)		; \
	.long	0	/* Link Field */	; \
	DEFCODE_4TH(label)


/*
 * It takes a bit of effort to remember that question_branch is taken
 * when the condition is false, so provide a more mnemonic and shorter
 * way to say it.
 */
#define OR_ELSE(label)	/* .long */ question_branch, label

/*
 * Syntactic sugar for single word THEN part
 */
#define THEN_RETURN(word) /* .long */ OR_ELSE(0f), word, exit_4th; 0:;


#define QUOTESTR(word, str)						  \
	/* .long */ ___CONCAT(_lparen,__CONCAT(word,_dquote_rparen))	; \
	.long	(22f - 21f)						; \
21:	.ascii	str							; \
22:	.p2align 2, 0 /* force new directive with ; */			;

#define SQ(str)		QUOTESTR(s, str)	/* s"     */
#define DOTQ(str)	QUOTESTR(_dot, str)	/* ."     */
#define ABORTQ(str)	QUOTESTR(abort, str)	/* abort" */

#define THROW(code) \
	/* .long */ lit, (code), throw

#define THEN_THROW(code)			  \
	/* .long */ OR_ELSE(0f), THROW(code)	; \
0:

#endif /* _FORTH_H_ */
